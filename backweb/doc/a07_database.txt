# 데이터 베이스 연동...

	# 전화기로 누구와 통화를 할 때..
	1. 전화기로 연결이 될려면 통신망 갖추어져야 합니다.
		==> driver : oracle.jdbc.driver.OracleDriver
		데이터베이스가 연결할 수 있게 필요로 하는 여러가지 추가적인 프로그램이 메모리로 로딩
		해서 처리되어 있어야 함 : Class.forName("oracle.jdbc.driver.OracleDriver");
		WEB-INF\lib\ojdbc11.jar
	2. 전화기로 전화번호를 입력/저장된 전화번호로 상대방에게 전화를 시도..
		==> jdbc:oracle:thin:@localhost:1521:xe 
			jdbc:oracle:thin: (전화기로 하면 통신사-서버종류)
			localhost- ip :(실제전화번호)  ex) 124.24.34.43 주소로 전세계 망으로 접속처리. 
											IPv4 주소 . . . . . . . . . : 192.168.0.17(학원안에서)
											고정ip 할당 받으면(통신사) 전세계적으로 유일하여 접속이 가능하다.
											localhost : 내가 현재 컴퓨터에 서버가 구축되어 있고, 그 서버는
												접속할 때 사용되는 loop back(자기가 자기를 호출)할 때 사용되는
												ip 주소 (개발할 때 주로 많이 활용됨 127.0.0.1)
												client, server가 같은 컴퓨터에서 테이스용으로 사용할 때 주로
												활용된다.
	3. 전화기로 연결 완료된 내용을 처리 : Connection
		Connection conn = DriverManager.getConnection(url,"scott","tiger");
	4. 전화를 했을 때, 연결이 안되거나 통신상 장애가 있는 부분을 메시지로 표현 하는 부분..
			try {
			} catch (ClassNotFoundException e) {
				System.out.println("클래스 예외:"+e.getMessage());
				==> 전화기로 비유하면 통신망 문제(jdbc드라이버 문제)
			} catch (SQLException e){
				System.out.println("sql 예외:"+e.getMessage());
				==> 전화기로 비유하면 연결이나 데이터베이스 sql 문제
			} catch(Exception e){
				System.out.println("기타 예외:"+e.getMessage());
				==> 기타 그외의 모든 문제..
			}	
	5. 전화를 끊었을 때 처리
		Connection 있는 메모리를 해제하는 처리..
		계층적으로 종속된 객체들이 있다.
		1) 기본 select문을 사용할 때 활용하는 객체(의사전달 후, 결과를 받을 때)
			연결(Connection) ==> 대화(Statement/PreparedStatement)
			==> 결과(ResultSet) 
		2) 등록/수정/삭제를 통해서 전달만 하는 객체(의사전달만하여 서버에 영향을 주는 경우)
			연결(Connection) ==> 대화(Statement/PreparedStatement)
			안정성을 위하여 commit/rollback 처리
		이렇게 종속적을 만들어진 객체는 한번에 자원해제를 하는 것이 아니라,
		반대로 ResultSet 자원해제 ==> Statement 자원해제 ==> Connection 자원해제를
		하여야 한다.
		==> 위 내용을 반드기 처리하여야 한다.
		
# 데이터 처리 부분
1. 만들어진 연동객체를 호출하여 연결처리
Connection con = DBConn.con();
	
2. try( 객체 ){} : 자동자원해제 기능...
   sql문을 작성한 내용을 기준으로 대화를 할 수 있는 객체 생성..
	- 실제 사용할 sql 구문을 처리
	String sql = "SELECT * FROM emp WHERE ename like ? ";
	PreparedStatement pstmt = con.prepareStatement(sql);
3. sql구문에 ?로 선언하여 mapping할 문자열을 매개변수로 받아서 처리
	메서드의 매개변수로 넘겨온 구분을 ?구문에 할당 처리..
	pstmt.setString(1, "%"+sch+"%"); == sql에 있는 ?의 갯수에 따라서 1,2,3 시작하여 순서별로 데이터를 mapping
4. sql을 통해 실행된 결과를  DB서버로 부터 받아서 2차원(테이블excel형식)으로된 ResultSet 객체에 할당.
	ps) ResultSet은 dbeaver에서 sql을 결과를 받은 데이터를 리스트하는 형식의 모든 정보를 담고 있다.
	즉, 컬럼정보, 행단위 데이터 정보
	ResultSet rs = pstmt.executeQuery();
5. 	ResultSet은 행단위로 변경할 때는 rs.next()라는 메서드를 호출하여 해당 행의 데이터가 있으면 true 없으면
	false를 리턴한다. 즉, 행이 12개가 있면 rs.next()를 12번까지 호출할 때, true가 나오고 그 이후로는 false가 나온다
	그래서 while(rs.next())로 할당하는 경우가 많다.
	System.out.println("데이터 있음:"+rs.next());
6. rs.next()를 통해서 행단위로 접근한다면, rs.getString("컬럼명"), rs.getString(1):select 1, 2, 3  순서로
	접근하여 해당 행에있는 컬럼의 데이터를 getXXXX() 타입에 맞게 호출하여 가져온다.
	System.out.println("첫번째 행의 첫번째 열데이터:"+rs.getString(1));
ex) select empno, ename, job from emp;
	sql을 수행 했고, 데이터가 12행이 있다면
	3행에 job컬럼에 있는 데이터를 가져올려면
	rs.next() 3번호출 한뒤
	rs.getString("job") 식으로 호출하여야 하고.
	실제로 전체 내용을 호출할 때는
	while(rs.next()){
		rs.getInt("empno");  또는 select 순서로 rs.getInt(1)
		rs.getString("ename");   또는 select 순서로 rs.getString(2)
		rs.getString("job");   또는 select 순서로 rs.getString(3)
	}
	로 처리하면 전체 데이터를 다 가져와서 처리하게 된다.	
# 위 내용 연습
				// 3번째행의 ename 컬럼 호출..
				//rs.next();rs.next();rs.next();
				//System.out.println("세번째 행의 ename 열데이터:"+rs.getString("ename"));
				// ex) 2번째 행의 job컬럼 데이터 호출
				//rs.next();rs.next();
				//System.out.println("job컬럼:"+rs.getString("job"));
				// ex) 5번째 행의 deptno컬럼 데이터 호출..
				//rs.next();rs.next();rs.next();rs.next();rs.next();
				//System.out.println("deptno컬럼:"+rs.getInt("deptno"));
# 데이터베이스에서 처리한 내용을 객체로 리턴하기
1. dao를 통해서 결과내용을 실무에서는 객체로 전달하여 화면에서 처리한다.
	1) jsp form으로 요청값 전달
			부서번호:[   ] [검색] (요청값처리)
			
			부서번호:@@@ dao의 리턴결과로 VO를 받아서 출력..
			부서명:@@
			부서위치:@@@
	2) dao 객체 생성 및 메서드의 요청값을 받아서 DB 결과 처리 후, 객체로 전달.
	3) jsp에서는 최종 결과 객체를 받아서, 화면에 구현 및 처리..
2. sql 처리 순서
	1) sql 구문 만들기 및 확인/매개변수를 ? 처리
		select *
		from dept
		where deptno = 10;	
		==>
		select *
		from dept
		where deptno = ?
select *
from dept
where deptno = ?
		
	2) 결과 sql에 따른 VO객체 생성하기
		sql에서 실행한 결과를 가지고 이 형태에 맞는 VO객체 선언
		위 경우, deptno, dname, loc를 컬럼으로 검색된 결과를 확인할 수 있다.
		class Dept{
			private int deptno;
			private String dname;
			private int loc;
			// 생성자
			// get/set 메서드 선언..
		}	
	3) Dao의 templet 복사 하여 리턴할 객체 선언
		public Dept getDept(int deptno){
			return dept;
		}
	4) 해당 메서드의 sql 구문 복사 및 pstmt 선언
		String sql = "select * from dept where deptno = ?;
	5) pstmt의 객체 mapping
		pstmt.setInt(1, deptno); 
	6) 다중 데이터 처리냐 단일 데이터 처리냐에 따라서 while(rs.next()), if(rs.next())
		구분하여 처리 위 경우 단일 데이터 검색(deptno가 key이기 때문)
	7) 객체의 생성자로 결과값을 통해 객체를 할다.
		dept = new Dept(rs.getInt("deptno"), rs.getSting("dname"), rs.getString("loc"));
	8) main() 메서드에서 호출 확인
		dao = new Dao();
		Dept res = dao.getDept(10);
		System.out.println("최종 객체확인:"+res);	
		System.out.println("최종 데이터 확인:"+res.getDeptno()+","+rs.getDname());			
ex) 
select empno, ename, sal, deptno
from emp
where empno = 	7369;
기반으로 위 기능 메서드를 만들어 주세요(위 순서 참고)

			
		
		
			 					
	
	
	
	
	
					
		
			
		
											
