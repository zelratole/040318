# 데이터 베이스 연동...

	# 전화기로 누구와 통화를 할 때..
	1. 전화기로 연결이 될려면 통신망 갖추어져야 합니다.
		==> driver : oracle.jdbc.driver.OracleDriver
		데이터베이스가 연결할 수 있게 필요로 하는 여러가지 추가적인 프로그램이 메모리로 로딩
		해서 처리되어 있어야 함 : Class.forName("oracle.jdbc.driver.OracleDriver");
		WEB-INF\lib\ojdbc11.jar
	2. 전화기로 전화번호를 입력/저장된 전화번호로 상대방에게 전화를 시도..
		==> jdbc:oracle:thin:@localhost:1521:xe 
			jdbc:oracle:thin: (전화기로 하면 통신사-서버종류)
			localhost- ip :(실제전화번호)  ex) 124.24.34.43 주소로 전세계 망으로 접속처리. 
											IPv4 주소 . . . . . . . . . : 192.168.0.17(학원안에서)
											고정ip 할당 받으면(통신사) 전세계적으로 유일하여 접속이 가능하다.
											localhost : 내가 현재 컴퓨터에 서버가 구축되어 있고, 그 서버는
												접속할 때 사용되는 loop back(자기가 자기를 호출)할 때 사용되는
												ip 주소 (개발할 때 주로 많이 활용됨 127.0.0.1)
												client, server가 같은 컴퓨터에서 테이스용으로 사용할 때 주로
												활용된다.
	3. 전화기로 연결 완료된 내용을 처리 : Connection
		Connection conn = DriverManager.getConnection(url,"scott","tiger");
	4. 전화를 했을 때, 연결이 안되거나 통신상 장애가 있는 부분을 메시지로 표현 하는 부분..
			try {
			} catch (ClassNotFoundException e) {
				System.out.println("클래스 예외:"+e.getMessage());
				==> 전화기로 비유하면 통신망 문제(jdbc드라이버 문제)
			} catch (SQLException e){
				System.out.println("sql 예외:"+e.getMessage());
				==> 전화기로 비유하면 연결이나 데이터베이스 sql 문제
			} catch(Exception e){
				System.out.println("기타 예외:"+e.getMessage());
				==> 기타 그외의 모든 문제..
			}	
	5. 전화를 끊었을 때 처리
		Connection 있는 메모리를 해제하는 처리..
		계층적으로 종속된 객체들이 있다.
		1) 기본 select문을 사용할 때 활용하는 객체(의사전달 후, 결과를 받을 때)
			연결(Connection) ==> 대화(Statement/PreparedStatement)
			==> 결과(ResultSet) 
		2) 등록/수정/삭제를 통해서 전달만 하는 객체(의사전달만하여 서버에 영향을 주는 경우)
			연결(Connection) ==> 대화(Statement/PreparedStatement)
			안정성을 위하여 commit/rollback 처리
		이렇게 종속적을 만들어진 객체는 한번에 자원해제를 하는 것이 아니라,
		반대로 ResultSet 자원해제 ==> Statement 자원해제 ==> Connection 자원해제를
		하여야 한다.
		==> 위 내용을 반드기 처리하여야 한다.
		
# 데이터 처리 부분
1. 만들어진 연동객체를 호출하여 연결처리
Connection con = DBConn.con();
2. sql문을 작성한 내용을 기준으로 대화를 할 수 있는 객체 생성..
	- 실제 사용할 sql 구문을 처리
	String sql = "SELECT * FROM emp WHERE ename like ? ";
	PreparedStatement pstmt = con.prepareStatement(sql);
3. sql구문에 ?로 선언하여 mapping할 문자열을 매개변수로 받아서 처리
	메서드의 매개변수로 넘겨온 구분을 ?구문에 할당 처리..
	pstmt.setString(1, sch);
4. sql을 통해 실행된 결과를  DB서버로 부터 받아서 2차원(테이블excel형식)으로된 ResultSet 객체에 할당.
	ps) ResultSet은 dbeaver에서 sql을 결과를 받은 데이터를 리스트하는 형식의 모든 정보를 담고 있다.
	즉, 컬럼정보, 행단위 데이터 정보
	ResultSet rs = pstmt.executeQuery();
5. 	ResultSet은 행단위로 변경할 때는 rs.next()라는 메서드를 호출하여 해당 행의 데이터가 있으면 true 없으면
	false를 리턴한다. 즉, 행이 12개가 있면 rs.next()를 12번까지 호출할 때, true가 나오고 그 이후로는 false가 나온다
	그래서 while(rs.next())로 할당하는 경우가 많다.
	System.out.println("데이터 있음:"+rs.next());
6. rs.next()를 통해서 행단위로 접근한다면, rs.getString("컬럼명"), rs.getString(1):select 1, 2, 3  순서로
	접근하여 해당 행에있는 컬럼의 데이터를 getXXXX() 타입에 맞게 호출하여 가져온다.
	System.out.println("첫번째 행의 첫번째 열데이터:"+rs.getString(1));
ex) select empno, ename, job from emp;
	sql을 수행 했고, 데이터가 12행이 있다면
	3행에 job컬럼에 있는 데이터를 가져올려면
	rs.next() 3번호출 한뒤
	rs.getString("job") 식으로 호출하여야 하고.
	실제로 전체 내용을 호출할 때는
	while(rs.next()){
		rs.getInt("empno");  또는 select 순서로 rs.getInt(1)
		rs.getString("ename");   또는 select 순서로 rs.getString(2)
		rs.getString("job");   또는 select 순서로 rs.getString(3)
	}
	로 처리하면 전체 데이터를 다 가져와서 처리하게 된다.	
	
	
	
	
	
	
					
		
			
		
											
