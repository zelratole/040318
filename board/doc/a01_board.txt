# 답변형 게시판 주요 기능
1. 기본 메인 조회 리스트
2. 게시글 등록
	1) 제목/작성자/내용/첨부파일(파일업로드)로 글등록 처리
3. 게시글 상세
	1) 제목, 작성자, 내용, 첨부파일(다운로드), 읽은 횟수
	2) 답글달기/수정/삭제
4. 답글달기
	상세글에서 답글을 달면 해당 글 하위에 메인 조회 리스트에서 출력
	된다.
5. 계층형 메인 조회 리스트
	1) 답글은 바로 아래 처리된 계층형으로 전체 리스트를 출력한다.
	2) 최근글이나 최근 답글은 최상위에 리스트하여 역순위로 정렬
	3) 하단에 페이징 리스트를 하여, 많은 글이라도 부하를 감소시켜서
		페이징 블럭마다 각각의 글리스트를 확인 할 수 있다.

# 상세화면 처리..
1. 리스트에서 특정 행단위를 클릭시, 상세화면으로 이동 처리
	boardDetail.do?no=@@@
2. 상세 내용이 조회된 화면 로딩
	번호			상위번호
	제목
	작성자        조회수
	등록일        수정일
	내용
	
	첨부파일
# 처리 순서
1. DB 처리
	1) sql작성
		select * from board where no = #{no}
		select fname from boardfile where no = #{no}
		update board
			set readcnt = readcnt + 1
		where no = #{no}
		
	2) dao 작성
		Board getBoard(@Param("no") int no);
		List<String> getBoardFile(@Param("no") int no);
		int uptReadCnt(@Param("no") int no);

	3) service
	4) controller
		boardDetail.do  no요청값 처리..
	------------------------------------
		
	5) jsp(view)
		boardList.jsp
			행단위 페이지 이동
			function goDetail(no){
				location.href=""
			}
		boardDetail.jsp	
			<input type="number" name="no" value="${board.no}" readonly/>
			번호			상위번호
			제목
			작성자        조회수
			등록일        수정일
			내용
			
			첨부파일			

# 게시물 수정 삭제 처리.
1. sql  작성
	1)  수정
	2)  삭제
------------------------
2. dao 처리

UPDATE BOARD 
	SET subject = #{subject},
	    content = #{content},
	    uptdte = sysdate
WHERE NO = #{no}

DELETE FROM board
WHERE NO = #{no}
	int updateBoard(Board upt);
	int deleteBoard(@Param("no") int no);
	
-------------------------------------	
3. service/controller 호출 처리
4. controller
	1) updateBoard.do
	2) deleteBoard.do
5. jsp
	1) 수정버튼 클릭시,
		$("form").attr("action","updateBoard.do")
	2) 삭제버튼 클릭시
		location.href="deleteBoard.do?no="+no

# 답글 처리..
1. 게시판에서 답글을 달아서, 해당 글에 대한 답변글을 바로 밑에 하단에 계층적으로
	붙이는 처리를 하는 것을 말한다.
2. 처리프로세스
	1) 상세화면에서 답글버튼 클릭시, 답글 등록 화면이 로딩.
	2) 답글내용 입력시
	3) 게시물 전체 화면에서 해당 글 밑에 붙는 것을 말한다.
	# 데이터베이스 
	no 1번글의 답글을 처리하면  새로운  no에 refno가 1로 등록되어
	처리된다. 이를 통해서 상/하위 계층 구조의 데이터를 처리되어
	계층형 sql 처리가 가능하다.
3. 개발 순서
	1) 상세글 화면에서 답글 클릭시
		요청값 전달 :
			제목 ==> RE:제목
			no ==> refno에 할당처리..
			내용 ==>  === 이전 글 ===
					 기존 글내용....
		위와 같이 해당 값으로 요청값을 전달하여 기본 화면 form에 출력되게 처리한다.
	2) 답글(기본 등록 화면에서 위와 같이 답글 관련 데이터를 전송한 상태에서 글등록 처리)
		글등록
			<input name="refno" value="${board.refno}"/> 
								
	
# 계층적 sql에 의한 답글리스트 처리
1. 오라클에서는 글과 상위글이라는 계층적 데이터로 계층적 sql을 처리할 수 있다.
2. 이 계층적 sql을 통해, 답변형 게시판의 경우, 해당 답글이 바로 밑에 처리되는 형식으로
	게시판의 리스트를 구현할 수 있다.
3. 계층적 sql의 원리와 구조
	1) 계층적 sql 처리를 위한 데이터 저장
		- 기본 데이터를 입력하면,
		- 이 기본 데이터를 기반으로 하는 상위/하위 컬럼이 존재하여야 한다.
		- 그래서, 두 컬럼간의 상/하위 관계에 의해 데이터가 저장되어 있을 때 가능하다.
		ex) emp 테이블의 경우 empno, mgr이 사원번호와 관리자번호가 계층적으로 데이터가
		저장되어 있다. 이렇게 상/하위 관계의 컬럼이 있을 때만 가능하다.
	2) 게시판에서 계층적 컬럼 구조
		- no 기본 글번호, refno 이글의 상위 글번호..
		- no/refno는 답글을 처리할 때, refno데이터가 저장이 된다.
	3) 계증적 sql의 주요 속성
		start with 컬럼명 = 조건데이터   : 최상위 계층의 데이터 조건을 선언한다.
		connect by prior 하위컬럼 = 상위컬럼  : 계층적으로 연결된 컬럼을 지정한다.
		order siblings by 컴럼명 desc : 기본적으로 같은 계층에 대하여 asc(오름차순이나), 내림 차순으로
										처리할 필요할 때, 옵션을 설정한다.
										ps) siblings : 형제....
	4) 게시판 sql 처리  == rownum 행단위 고유 numbering 처리, level 계층레벨..
		select rownum cnt, level, b.*   
		from board b
		where subject like '%%'
		and writer like '%%'
		start with refno = 0
		connect by prior no = refno
		order siblings by no desc
		
		;
		==> vo(board) cnt, level													
	7) 화면단
		제목은 기본적으로 왼쪽 정렬 처리, 계층레벨(level)을 가져와서, 레벨에 따라서 공백 처리..


# 하단에 paging 처리 로직..
1. 게시판 페이지 처리란?
	게시판내용은 데이터가 늘어날 수로 DB/화면단 부하를 초래한다.
	이러한 부하를 경감하기 위하여, 하단이나 상단에 paging처리를 하여 
	한 화면에 볼 수 있는 데이터 건수를 정하여, 그 이상의 데이터는 paging으로
	여러 개의 내용으로 화면별로 처리하여, 화면과 DB에 대한 부하를 줄여서
	효과적으로 데이터를 처리할 수 있다.
2. 기본 인터페이스
	1) 초기에 한 화면에 지정한 데이터 건수(5)를 한 화면에서 볼 수 있고,
		하단에, 게시판에 등록된수만큼 페이징(총데이터건수/한번에 보일 데이터 건수)
		이 처리되어 리스트가 나타나는 것을 볼 수 있다.
	2) 각 페이지 번호를 클릭하면, 해당 페이지의 데이터 목록을 볼 수 있다.
		1페이지(1~5),  3페이지(11~15) .....
	3) 하단에 보일 수 있는 페이지로 지정하여 그 이상이 되면 next로 페이지 블럭별로
		도 페이징이 처리되어 있는 것을 볼 수 있다. 페이지 블럭은 previous/next로
		3,5,7 등 홀 수로 한번에 보이는 페이지 번호와 왼쪽/오른쪽으로 블럭단위로 페이지
		리스트가 출력되게 한다.
3. 구현 순서
	1) sql문
		기본 sql문에서 고유 속성값 rownum(데이터 row단위 출력)을 기준으로
		cnt를 alias로 한 시작번호와 마지막번호를 기준으로 화면에 출력되는 것이 데이터의
		기본 로직이다.
		where cnt between 1 and 5  : 1페이지인 경우
		where cnt between 6 and 10  : 2페이지인 경우
		where cnt between 11 and 15  : 3페이지인 경우
	2) vo 처리
		위의 내용과 같이 각 페이지 번호별로 시작번호와 마지막번호를 입력하는 것 이외에
		요청값 : 현재클릭한 페이지 번호, 한번에 보일 페이지 갯수,
		출력할 내용 : 총 페이지 수, 블럭단 시작할 시작번호, 마지막번호, 
		등의 여러가지 페이징 처리를 위해 속성이 추가적으로 필요하여 BoardSch라는 요청처리와
		모델처리는 같이 하는 VO가 따로 필요로 한다.
		주요 속성 : 검색-제목(subject),작성자(writer)  
		기본페이지처리 - 전체데이터건수(count), 한번에 보여줄 데이터 건수(pageSize), 
			총페이지수(pageCount), 현재 클릭한 페이지 번호(curPage),
			시작번호(start), 마지막번호(end)
		페이지블럭처리 - 한번에 보여줄 block의 크기(blockSize), block 시작번호(startBlock),
					 block 마지막번호(endBlock)
	3) dao
		- 검색하는 VO 생성
		- 전체 기본 데이터를 가져오는 처리
			int getBoardCount()
		- 페이징 처리되는 데이터	 
			List<Board> getBoardList(BoardSch sch);
	
	4) service(***)

		// 1. 총데이터 수(DB)
		sch.setCount(dao.getBoardCount(sch));
		
		// 2. 현재 클릭한 번호(화면단 요청값)..- 초기값 1(첫번째페이지)
		if(sch.getCurPage()==0) {
			sch.setCurPage(1);
		}
		
		// 3. 한페이지에 보일 데이터 건수(화면단 선택으로 요청값) - 초기값5(첫번째 페이지)
		if(sch.getPageSize()==0) {
			sch.setPageSize(5);
		}
		
		// 4. 총페이지수(수치연산/알고리즘 - 총데이터건수/한페이지에 보일 데이터 수)
		
		//    13건   5  ==>  13/5 ==> 2.6  ==> 3.0 ==> 3
		//                  10/5 ==> 2   ==> 2.0 ==> 2
		//                  7/5 ==> 1.4 ==> 2.0 ==> 2
		//                  5/5 ==> 1  ==> 1.0 ==> 1
		//  정수/정수 ==> 실수/정수 vs 정수/실수 ==> 실수
		// sch.getCount()/sch.getPageSize() ==> 정수..
		//  sch.getCount()/(double)sch.getPageSize() ==> 실수
		//  Math.ceil(sch.getCount()/(double)sch.getPageSize()) ==> 실수
		// (int)(Math.ceil(sch.getCount()/(double)sch.getPageSize())) ==> 정수
		sch.setPageCount( (int)(Math.ceil(sch.getCount()/(double)sch.getPageSize())) );
		// 5. 시작번호/마지막번호 -  마지막번호?( 한페이지에 보일 데이터 건수*현재 클릭한 번호)
		///   1페이지 클릭 ==> 1~5
		///   2페이지    ==> 6~10
		//    3페이지    ==> 11~15
		//    4페이지    ==> 16~20     17...
		//   ex) 3 ===>  1,4,7,10....
		//   ex) 10 ===>  1,11,21,31....
		//    마지막번호는 마지막데이터건수보다 클 수 없다.. 
		//    if( sch.getCount() < sch.getEnd() )
		//    	sch.setEnd( sch.getCount() )
		
		sch.setStart((sch.getCurPage()-1)*sch.getPageSize()+1);
		
		int imEnd = sch.getPageSize()*sch.getCurPage();
		sch.setEnd(imEnd > sch.getCount()?sch.getCount():imEnd);
		
		
		// start, end  ==> 특정 페이지 범위에 데이터 출력..
		
		// 6. 페이징 블럭 처리..
		/*
		이전 [ 1][ 2][ 3][ 4][ 5] 이후  ==> 1번 block
		이전 [ 6][ 7][ 8][ 9][10] 이후  ==> 2번 block
		이전 [11][12][13] 이후          ==> 3번 block
		
		특정 페이지번호에 시작블럭 번호와 마지막 번호를 BoardSch에 설정함으로 화면에서 위와 같은
		UI(user interface)를 보이게 하기 위한 것이다.
		결국은 각 block에서 시작블럭번호(startBlock)과 마지막블럭번호(endBlock)를 화면단에 넘겨주어서
		출력하기 위해서 처리하는 것이다.
		 * */
		// 	1) 블럭 크기 설정.-일반적으로 홀수로 정함..
		sch.setBlockSize(5);
		//  2) 블럭 번호 지정..1~5 ==> 1,  6~10 ==> 2,  11~15 ==> 3...
		//  (int) Math.ceil(sch.getCurPage()/(double)sch.getBlockSize())  1/5, 2/5, 3/5, 4/5, 5/5 =>1
		int blockNum = (int) Math.ceil(sch.getCurPage()/(double)sch.getBlockSize());
		//  3) 시작블럭
		sch.setStartBlock((blockNum-1)*sch.getBlockSize()+1);
		//  4) 마지막블럭..
		int endBlock = blockNum*sch.getBlockSize();
		sch.setEndBlock( (endBlock>sch.getPageCount())?sch.getPageCount():endBlock );
		

	
	5) view(jsp)				 	
	 	<input type="hidden" name="curPage" value="${sch.curPage}"/>
		</form>	
		
		<ul class="pagination justify-content-end">
	  <li class="page-item"><a class="page-link" href="javascript:goPage(${sch.startBlock-1})">Previous</a></li>
	  <c:forEach var="pCnt" begin="${sch.startBlock}" 
	  						end="${sch.endBlock}">
	  <li class="page-item ${sch.curPage==pCnt?'active':''}">
	  	<a class="page-link" href="javascript:goPage(${pCnt})">${pCnt}</a></li>
	  </c:forEach>
	  <li class="page-item"><a class="page-link" href="javascript:goPage(${sch.endBlock+1})">Next</a></li>
	</ul>	
	<script type="text/javascript">
		function goPage(pCnt){
			$("[name=curPage]").val(pCnt)  // 클릭한 것을 현제 페이지 번호로 전송.. 페이지가 이동 처리.
			$("form").submit()
			
		}
	</script>	
		
		 		
		
		
		
		
		
		
						
	
	
	        
		





		