2024-05-31 


 요구사항은 분석 후 개체로 분석하고, 두 개의 개체는 응시라는 관계가 있다고 가정할 때, 개체의 관계를 적으시오
 
 
 다음프로시저를 생성하시오. 
  1) 프로서지 이름 : output_member, 필요에 의해 변수선언
  2) table 구조 :  member(id(pk), namel)
  3) execute output_member('kkk')을 실행하면 kkk아이디를 가진 사람의 이름을 출력한다.
  4) 프로시저 생성 시 기존에 프로시저가 있다면 기존 프로시저를 삭제하고 생성하시오. 
 

GOracleDB에서 지정된 요구 사항을 충족하는 프로시저를 생성하기 위해 다음과 같은 SQL 명령어를 사용할 수 있습니다. 이 프로시저는 주어진 아이디(`id`)를 가진 사람의 이름(`name`)을 출력합니다.

### 프로시저 생성

다음 SQL 스크립트는 `output_member`라는 프로시저를 생성합니다. 이 프로시저는 `member` 테이블에서 주어진 `id`를 가진 사람의 이름을 출력합니다.

```sql
-- 기존 프로시저가 있는 경우 삭제
DROP PROCEDURE IF EXISTS output_member;

-- 프로시저 생성
CREATE OR REPLACE PROCEDURE output_member (p_id IN VARCHAR2) 
IS
    v_name member.name%TYPE;
BEGIN
    -- 주어진 id에 해당하는 이름을 선택
    SELECT name INTO v_name 
    FROM member 
    WHERE id = p_id;
    
    -- 이름 출력
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No member found with ID: ' || p_id);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
```

### 프로시저 설명

1. **기존 프로시저 삭제**:
   ```sql
   DROP PROCEDURE IF EXISTS output_member;
   ```
   기존에 `output_member` 프로시저가 있으면 삭제합니다. `IF EXISTS`는 일부 SQL 데이터베이스에서는 사용되지만, Oracle에서는 직접적으로 사용할 수 없으므로 다음과 같이 변경해야 할 수 있습니다:
   ```sql
   BEGIN
      EXECUTE IMMEDIATE 'DROP PROCEDURE output_member';
   EXCEPTION
      WHEN OTHERS THEN
         NULL; -- 프로시저가 없으면 예외를 무시
   END;
   ```

2. **프로시저 생성**:
   ```sql
   CREATE OR REPLACE PROCEDURE output_member (p_id IN VARCHAR2) 
   IS
       v_name member.name%TYPE;
   BEGIN
       SELECT name INTO v_name 
       FROM member 
       WHERE id = p_id;
       
       DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
   EXCEPTION
       WHEN NO_DATA_FOUND THEN
           DBMS_OUTPUT.PUT_LINE('No member found with ID: ' || p_id);
       WHEN OTHERS THEN
           DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
   END;
   ```

   - `CREATE OR REPLACE PROCEDURE output_member (p_id IN VARCHAR2)`: `output_member` 프로시저를 생성하거나 기존 프로시저를 대체합니다. `p_id`는 입력 파라미터로, `id` 값을 받습니다.
   - `v_name member.name%TYPE;`: `member` 테이블의 `name` 열과 같은 데이터 타입을 가진 변수를 선언합니다.
   - `SELECT name INTO v_name FROM member WHERE id = p_id;`: `id`가 `p_id`와 일치하는 레코드의 `name` 값을 `v_name` 변수에 저장합니다.
   - `DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);`: `v_name` 값을 출력합니다.
   - 예외 처리 블록을 사용하여 데이터가 없는 경우와 다른 오류 상황을 처리합니다.

### 프로시저 실행

아래 명령어를 사용하여 프로시저를 실행할 수 있습니다.

```sql
SET SERVEROUTPUT ON;
EXECUTE output_member('kkk');
```

- `SET SERVEROUTPUT ON;`: `DBMS_OUTPUT.PUT_LINE`의 출력을 화면에 보여주기 위해 서버 출력 설정을 켭니다.
- `EXECUTE output_member('kkk');`: `output_member` 프로시저를 실행하고, `id`가 'kkk'인 사람의 이름을 출력합니다.

이제 이 스크립트를 실행하여 프로시저를 생성하고, 주어진 `id`에 해당하는 이름을 출력할 수 있습니다.



 
  다음 프로시저를 생성하시오
  1) 프로시저 이름 : update_member, 필요에 의해 변수선언
  2) table 구조 :  member(id(pk), name)
  3) execute input_member('hm01','홍길동‘)을 실행하면 member table에 해당 hm01아이디의 이름이 홍길동으로 갱신된다.
  4) 프로시저 생성 시 기존에 프로시저가 있다면 생성하지 않도록 설정하시오.
 
 
회원의 아이디로 검색(실행부 참조) 하는 테스트 구문을 작성하려고 한다. 빈칸을 채우시오
1. 회원의 이름은 중복될 수 없다
2. 변수 설정 시 테이블의 속성과 크기가 일치해야 한다.
3. 회원의 정보는 아이디로 검색하며 아이디는 변할 수 있다. (실행부 참조)
 
create table employee(
eno number(4),
ename varchar2(20)
);

CREATE procedure test(indata in varchar2)
is  v_eno NUMBER(4);  v_ename (   가   );   // 테이블의 속성과 크기가 일치해야 한다.begin  dbms_output.put_line('사원번호    사원이름');  dbms_output.put_line('----------------------');
  
  SELECT  (나),(다)  (라)  v_eno, v_ename  FROM employee WHERE ename= ( 마  );
   dbms_output.put_line(v_eno ||'      '||v_ename);
END;
/
실행부 : exec test('kim')  // kim은 회원의 아이디이고 변할 수 있다.



DBA 의 데이터 최적화 기법을 모두 고르시오. (4개)
  가. 물리적 구조 최적화
  나. 메모리 할당 최적화
  다. I/O분산 최적화
  라. 메모리 경합 최적화
  마. 테이블 개수
  바. 속성의 정확도


DBA의 데이터 최적화 기법 중에서 올바른 것들을 고르는 문제입니다. 최적화 기법으로 여겨질 수 있는 항목들을 살펴보면, 다음과 같습니다:

1. **물리적 구조 최적화**: 데이터베이스의 물리적 구조를 최적화하는 것은 성능 향상을 위해 매우 중요합니다. 여기에는 테이블의 분할, 인덱스 설정, 데이터 파일의 배치 등이 포함됩니다.
   
2. **메모리 할당 최적화**: 데이터베이스 성능을 향상시키기 위해 메모리 할당을 최적화하는 것이 필요합니다. 이를 통해 캐싱, 버퍼 관리 등이 효율적으로 수행될 수 있습니다.
   
3. **I/O 분산 최적화**: 데이터베이스의 입출력(I/O) 작업을 분산하여 병목 현상을 줄이는 것이 중요합니다. 이를 위해 디스크 I/O를 분산시키거나 RAID 구성을 사용하는 등의 방법이 있습니다.
   
4. **메모리 경합 최적화**: 메모리 자원의 경합을 최소화하여 성능을 높이는 것이 필요합니다. 이를 위해 적절한 메모리 할당과 세그먼트 설정을 조정하는 등의 방법을 사용합니다.

따라서, 올바른 최적화 기법을 모두 고르면 다음과 같습니다:

- **가. 물리적 구조 최적화**
- **나. 메모리 할당 최적화**
- **다. I/O 분산 최적화**
- **라. 메모리 경합 최적화**

이 네 가지 항목이 DBA가 사용하는 주요 데이터 최적화 기법에 해당합니다.



 Trace 결과로 파악할 수 있는 분석 정보를 모두 고르시오. (4개)
  가. 물리적/ 논리적 Reads
  나. 처리된 튜플수
  다. 파싱이 발생 할 때의 사용자
  라. 커밋/롤백
  마. 접속한 사용자 추적

Trace 결과로 파악할 수 있는 분석 정보를 모두 고르는 문제입니다. Trace 결과는 데이터베이스의 성능 문제를 분석하고 최적화하기 위해 사용됩니다. 올바른 항목들을 살펴보면 다음과 같습니다:

1. **물리적/논리적 Reads**: Trace 결과에는 SQL 문장이 실행되는 동안 발생한 물리적 읽기와 논리적 읽기의 수를 포함할 수 있습니다. 이는 데이터베이스 I/O 성능을 분석하는 데 중요한 정보입니다.
   
2. **처리된 튜플수**: Trace 결과에서 SQL 문장이 실행된 후 처리된 행(튜플)의 수를 알 수 있습니다. 이는 쿼리의 결과로 얼마나 많은 데이터가 처리되었는지를 나타냅니다.
   
3. **파싱이 발생할 때의 사용자**: SQL 문장이 파싱될 때 어떤 사용자가 해당 문장을 실행했는지를 Trace 결과에서 파악할 수 있습니다. 이는 파싱 관련 성능 문제를 분석하는 데 도움이 됩니다.
   
4. **커밋/롤백**: Trace 결과에는 트랜잭션의 커밋과 롤백 정보도 포함될 수 있습니다. 이는 트랜잭션이 완료되었는지 또는 취소되었는지에 대한 정보를 제공합니다.

따라서, Trace 결과로 파악할 수 있는 분석 정보는 다음과 같습니다:

- **가. 물리적/논리적 Reads**
- **나. 처리된 튜플수**
- **다. 파싱이 발생할 때의 사용자**
- **라. 커밋/롤백**

위 네 가지 항목이 Trace 결과로 파악할 수 있는 주요 분석 정보에 해당합니다. 

**마. 접속한 사용자 추적**은 일반적으로 Trace 파일에서 직접적으로 제공되지 않는 정보입니다. 이는 주로 로그인을 추적하는 감사(Audit) 로그에서 제공됩니다.



성능개선에 대한 설명으로 옳은 것을 보두 고르시오. (4개)
 가. 가능한 where=을 많이 써서 범위가 아닌 특정 값 지정으로 인한 범위를 줄여 처리속도를 빠른게 한다.
 나. 부분범위 처리의 경우 서브쿼리 보다는 조인이 성능에 좋다.
 다. 성능에 중요한 엑세스 경로를 고려하여 인덱스화 한다.
 라. 실행계획을 검토하여 기존 인덱스의 열 순서를 변경하거나 추가 할 수가 있도록 한다.
 마. 사용하지 않은 불필요한 인덱스들은 제거한다. 

성능 개선에 대한 설명으로 옳은 것들을 모두 고르는 문제입니다. 각 항목을 하나씩 검토하여 성능 개선과 관련된 옳은 설명인지 확인해 보겠습니다.

### 검토 결과:

1. **가. 가능한 where=을 많이 써서 범위가 아닌 특정 값 지정으로 인한 범위를 줄여 처리속도를 빠르게 한다.**
   - **옳음**: WHERE 절에 특정 값을 사용하는 것이 범위 조건을 사용하는 것보다 더 나은 성능을 제공할 수 있습니다. 이는 데이터베이스가 더 작은 데이터 집합을 검색할 수 있도록 하여 처리 속도를 향상시킵니다.

2. **나. 부분범위 처리의 경우 서브쿼리 보다는 조인이 성능에 좋다.**
   - **옳음**: 부분 범위 처리를 할 때 서브쿼리보다는 조인이 더 나은 성능을 제공할 수 있습니다. 조인은 데이터베이스 엔진이 두 테이블 간의 연관성을 더 효율적으로 처리할 수 있도록 합니다.

3. **다. 성능에 중요한 엑세스 경로를 고려하여 인덱스화 한다.**
   - **옳음**: 중요한 액세스 경로에 대해 인덱스를 생성하면 데이터베이스의 검색 성능이 크게 향상될 수 있습니다. 올바른 인덱스를 사용하면 쿼리의 응답 시간이 단축됩니다.

4. **라. 실행계획을 검토하여 기존 인덱스의 열 순서를 변경하거나 추가할 수가 있도록 한다.**
   - **옳음**: 실행 계획을 검토하여 인덱스의 열 순서를 변경하거나 새로운 인덱스를 추가하는 것은 성능 최적화에 중요한 단계입니다. 실행 계획을 통해 쿼리의 실제 실행 방법을 분석하고 최적화를 수행할 수 있습니다.

5. **마. 사용하지 않은 불필요한 인덱스들은 제거한다.**
   - **옳음**: 사용하지 않는 인덱스를 제거하면 데이터베이스의 유지 관리 및 성능 최적화에 도움이 됩니다. 불필요한 인덱스는 삽입, 업데이트, 삭제 작업의 성능을 저하시킬 수 있습니다.

따라서, 성능 개선에 대한 옳은 설명을 모두 고르면 다음과 같습니다:

- **가. 가능한 where=을 많이 써서 범위가 아닌 특정 값 지정으로 인한 범위를 줄여 처리속도를 빠르게 한다.**
- **나. 부분범위 처리의 경우 서브쿼리 보다는 조인이 성능에 좋다.**
- **다. 성능에 중요한 엑세스 경로를 고려하여 인덱스화 한다.**
- **라. 실행계획을 검토하여 기존 인덱스의 열 순서를 변경하거나 추가할 수가 있도록 한다.**
- **마. 사용하지 않은 불필요한 인덱스들은 제거한다.**

이 다섯 가지 항목 모두 성능 개선에 중요한 요소들입니다.




 
 